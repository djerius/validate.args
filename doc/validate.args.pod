=head1 NAME

validate.args - validate arguments

=head1 SYNOPSIS

  va = require('validate.args')
  validate = va.validate
  validate_opts = va.validate_opts

  local a, b = validate( { a = { optional = 0 },
                           b = { optional = 1, type = 'table' },
                         },
                          ...
                        )
  local a, b = validate_opts( options,
                             { a = { optional = 0 },
                               b = { optional = 1, type = 'table' },
                             },
                            ...
                            )

=head1 DESCRIPTION

B<validate.args> validates that a function's arguments meet certain
specifications.  Both scalar and table arguments are validated, and
table arguments may be nested.

Specification details are specified in tables, one table per argument.

If a function is passed only named arguments, as in

  foo{ a = 3, b = 'n' }

then the specifications should be bundled into a table with the argument
names as keys:


  { a = { specs for a }, b = { specs for b } }

If a function is passed positional arguments, as in

  foo( 3, 'n' )

then the specifications should be bundled as a list:

  { { specs for arg 1 }, { specs for arg 2 } }


One can in a sense I<mix> the two forms by using both tables and scalars,

  foo( 3, 'n', { opta = 1, optb = 2 } )

where the last table is really just the third positional argument. This
form is useful for passing in named options alongside required positional
arguments.

Positional arguments may also be converted to named arguments (see
L</Validation Options>)

=head2 Validation Specifications

Multiple validation constraints may be specified for each argument and
are tested in random order.  The caller may provide constraints checks
which modify the passed arguments; these must not expect a particular
sequence of checks.

Validation specifications are attribute name-value pairs stored in tables,
with the attribute names as keys.  The following attributes are
recognized:

=over

=item optional

This is a boolean attribute which, if true, indicates that the argument
need not be present.  Positional as well as named arguments may be
optional; if they are not at the end of the list they may be specified
as C<nil> in the function call, e.g.

  foo( nil, 3 )

By default all arguments are required.

=item default

This provides the value for the argument if it is not specified, as
well as indicating that the argument is optional.

=item type

This specifies the expected type of argument. It may be either a single
type or a list of types:

  type = 'number'
  type = { 'number', 'boolean' }


Types are specified as strings, with the following available:

=over

=item 'nil'

=item 'number'

=item 'string'

=item 'boolean'

=item 'table'

=item 'function'

=item 'thread'

=item 'userdata'

These are the built-in types as returned by the Lua B<type> function.

=item 'posnum'

The argument must be a number greater than zero.

=item 'zposnum'

The argument must be a number greater than or equal to zero.

=item 'posint'

The argument must be an integer greater than zero.

=item 'zposint'

The argument must be an integer greater than or equal to zero.

=back

To add additional types see the B<add_type> function.

=item enum

This specifies one or more explicit values which the argument may
take. It may be either a single value or a list of values:

  enum = 33
  enum = { 'a', 33, 'b' }


=item not_nil

This is a boolean and indicates that the value must not be nil.  This
only pertains to positional arguments.

=item requires

This lists the names of one or more arguments which I<must> be specified
in addition to the current argument.  The value is either a single
name or a list of names:

  requires = 'arg3'
  requires = { 'arg3', 'arg4' }

See also L</Argument Groups>

=item excludes

This lists the names of one or more arguments which I<may not> be specified
in addition to the current argument.  The value is either a single
name or a list of names:

  excludes = 'arg3'
  excludes = { 'arg3', 'arg4' }

See also L</Argument Groups>

=item vfunc

This specifies a function which is called to validate the argument.
It is called with a single argument, the passed argument
value.  It must return two values.  The first is a boolean indicating
whether validation was successful.  If it was successful the second
value is the possibly transformed argument value.  If it failed, the
second value is an error message.

For example,

  vfunc = function( orig )
            if type(orig) == 'number' and orig >= 3 then
              return true, orig / 22
            end
              return false, 'not a number or less then 3'
          end


=item vtable

This specifies a table of specifications which will be used to
validate an argument which is a table.  The table is a set of
validation specifications.  The argument I<must> itself be a table.
This is how nested tables of arguments are validated. For example, the
following validation specificaton:

  { arg1 = { vtable =
              { arg2 = { vtable =
                           { arg3 = { type = 'string' } } } } } }

will correctly validate the equivalent of

     arg1 = {}
     arg1.arg2 = {}
     arg1.arg2.arg3 = 'foo'


It is possible to choose which specification table to use based upon
the value of the argument.  To do this, specify a function, rather
than a table.  The function is called as C<func(arg)>. It must return
two values.  The first is a boolean indicating success or failure.  Upon
success, the second argument must be a table of validation specifications.
Upon error, the second argument should be an error message.

For example, to choose the validation table based upon the first
positional argument in a table:

  specs = { gaussian = { {}, sigma = { type = 'number' } },
            uniform  = { {},  },
	    powerlaw = { {}, alpha = { type = 'number' } },
	  }

and later in the validation specification:


  { idist = { vtable = function (arg)
                          local vtable = specs[arg[1]]
			  if vtable then
			    return true, vtable
                          else
			    return false, "unknown idist: " .. tostring(arg)
			  end
                       end } }


=item name

A name for a positional argument.  If specified and the C<named>
validation option is I<true>, then the argument will be assigned this
name in the returned argument table.

=back

=head2 Groups of Arguments

Some operations on groups of arguments are possible for named
arguments.  These are specified as special "arguments" in the
validation specification.  In order to accomodate multiple groups,
these "arguments" take as values a I<list of lists>, not a simple list:

  ['%one_of'] = { { 'a', 'b', 'c' } }

B<not>

  ['%one_of'] = { 'a', 'b', 'c' }

This allows specifying multiple groups:

  ['%one_of'] = { { 'a', 'b', 'c' } , { 'd', 'e', 'f' } }

=over

=item %one_of

This ensures that exactly one argument in a group is specified.  For
example, say that the caller must provide exactly one of the arguments
C<arg1>, C<arg2>, or C<arg3>.  Exclusivity is obtained via

  arg1 = { optional = true, excludes = { 'arg2', 'arg3' } },
  arg2 = { optional = true, excludes = { 'arg1', 'arg3' } },
  arg3 = { optional = true, excludes = { 'arg1', 'arg2' } }

But that doesn't force the user to specify any.  This addition will:

  ['%one_of'] = {{ 'arg1', 'arg2', 'arg3' }}

Note that specifying the C<excludes> attribute is redundant with C<%one_of>,
so the above could be rewritten as

  arg1 = { optional = true },
  arg2 = { optional = true },
  arg3 = { optional = true }
  ['%one_of'] = {{ 'arg1', 'arg2', 'arg3' }}


=item %oneplus_of

This ensures that at least one argument in a group is specified. More
may be specified.  As a complicated example:

  sigma   = { optional = true, excludes = { 'sigma_x', 'sigma_y' } },
  sigma_x = { optional = true, requires = { 'sigma_y' } },
  sigma_y = { optional = true, requires = { 'sigma_x' } },
  ['%oneplus_of'] = { { 'sigma_x', 'sigma_y', 'sigma' } },

ensures that only one of the two following situations occurs:

  sigma
  sigma_x sigma_y



=back

=head2 Validation Options

There are a few options which affect the validation process.  These
may be set for individual validations using B<validate_opts()>, or may
be set globally for validations done via B<validate()> using
B<opts()>.

=over

=item check_spec

By default the passed validation specification is not itself checked
for consistency, as this may be too much of a performance hit.  Setting
this to C<true> will cause the specifications to be checked.

This defaults to C<false>.

=item error_on_invalid

If C<true>, the Lua B<error()> function will be called the case of
invalid arguments instead of returning a status code and message.

This defaults to C<false>.

=item error_on_bad_spec

If this is C<true>, an invalid validation specification will result in a
call to the Lua B<error()> function.

This defaults to C<false>.

=item named

If this is C<true>, positional arguments are returned as a table, with
their names given either by the C<name> attribute in the validation
specification or by their cardinal index in the argument list.
For example:

   ok, opts = validate_opts( { named = true },
                             { { name = a }, { }, },
			     22, 3
			      )

will result in

   opts.a = 22
   opts[2] = 3


This defaults to C<false>.

=item allow_extra

If this is C<true>, then any extra arguments (either named or positional)
which are not mentioned in the validation specification are quietly
ignored. For example:

  local ok, a, b, c = validate_opts( { allow_extra = true,
                                       pass_through = true,
				      },
                                      { {}, {} },
				     1, 2, 3)

would result in

  a = 1
  b = 2
  c = nil

This defaults to C<false>.

=item pass_through

If this is C<true> and C<allow_extra> is also C<true>, then any extra
arguments (either named or positional) which are not mentioned in the
validation specification are passed through.  For example:

  local ok, a, b, c = validate_opts( { allow_extra = true,
                                       pass_through = true,
				      },
                                      { {}, {} },
				     1, 2, 3)

would result in

  a = 1
  b = 2
  c = 3

This defaults to C<false>.

=item baseOptions

This option is useful only for the validation functions which take an
options table (such as validate_opts()). If C<true>, any options which
are not specified in the options table will be set from the global
options table as modified by the B<opts()> function.  Normally they
are set from the default options values.

This defaults to C<false>.

=back

=head2 Functions

=over

=item validate( specs, ... )

Validate the passed argument list against the specifications.  It
returns a list of values.  The first value is a boolean indicating
whether or not the validation succeeded.

If validation succeeded, the remainder of the list contains the
values of the arguments (possibly modified during the validation).

If validation failed, the second value is a string indicating what
caused the failure.


=item validate_opts( opts, specs, ... )

Validate the passed argument list against the specifications.  The
validation workflow may be altered via options passed via the C<opts>
argument.  The return arguments are the same as B<validate>.

Those options which are not set in C<opts> are set to the default
values.  If instead they should be set to the values which were
specified by the B<opts()> function, set the special option
C<baseOptions> to C<true>.

=item validate_tbl( opts, specs, tble )

Validate the contents of the passed table against the specifications.
The validation workflow may be altered via options passed via the
C<opts> argument.  The return arguments are the same as B<validate>.

Those options which are not set in C<opts> are set to the default
values.  If instead they should be set to the values which were
specified by the B<opts()> function, set the special option
C<baseOptions> to C<true>.


=item add_type( type_name, func )

Register a validation function for the named type which
will be accepted by the B<type> validation attribute.

The function will be passed the argument to validate.  It should return a
list of values.  The first value is a boolean indicating whether or
not the validation succeeded.

Upon success it should return the (possibly modified) argument as the second value.

For example, the following

  add_type( 'mytype', function( arg )
                          return 'number' == type(arg) and  arg > 2 and arg < 3,
			         3 * arg
			   end
          )

adds a new type called C<mytype> which accepts only numbers between 2 and 3 (exclusive)
and modifies the argument by multiplying it by 3.


=back

=head1 EXAMPLES

=over

=item * Named parameters, some optional

  function foo( ... )
    local ok, args = validate( { a = { type = 'number' },
                                 b = { default  = 22,
				       type = 'number' },
                     }, ... )
  end

If called as

  foo{ a = 12 }

then

  args.a = 12
  args.b = 22

=item * Positional parameters and optional named ones

  function bar( ... )
    local ok, arg1, arg2, opts
                   = validate( { { type = 'string' },
                                 { type = 'number' },
                                 { vtable = {
                                     a = { default = true,
                                           type = 'boolean' },
                                     b = { default = 22,
                                           type = 'number' },
                                   },
                                 }
                               }, ... )
  end

If called as

  bar( 'a', '22', { b = 33 } )

then

  arg1 = 'a'
  arg2 = 22
  opts.a = true
  opts.b = 33



=back

=head1 AUTHOR


Diab Jerius, E<lt>djerius@cfa.harvard.eduE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2010 by the Smithsonian Astrophysical Observatory

This software is released under the GNU General Public License.
You may find a copy at L<http://www.fsf.org/copyleft/gpl.html>.

=cut
